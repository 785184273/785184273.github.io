(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{608:function(t,s,a){"use strict";a.r(s);var e=a(5),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"prototype和-proto"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prototype和-proto"}},[t._v("#")]),t._v(" prototype和__proto__")]),t._v(" "),a("h3",{attrs:{id:"隐式原型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#隐式原型"}},[t._v("#")]),t._v(" 隐式原型")]),t._v(" "),a("p",[t._v("在js中任意对象都有一个内置属性[[prototype]]，在es5之前没有标准方法访问这个属性，但是大多数的浏览器都支持通过"),a("code",[t._v("__proto__")]),t._v("来访问。即：每个对象都有"),a("code",[t._v("__proto__")]),t._v("属性。")]),t._v(" "),a("h3",{attrs:{id:"显式原型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#显式原型"}},[t._v("#")]),t._v(" 显式原型")]),t._v(" "),a("p",[t._v("每个函数在创建之后都会有一个"),a("code",[t._v("prototype")]),t._v("属性，这个属性指向函数的原型对象，即："),a("code",[t._v("prototype")]),t._v("是函数才会有的属性。")]),t._v(" "),a("h3",{attrs:{id:"proto-的指向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proto-的指向"}},[t._v("#")]),t._v(" __proto__的指向")]),t._v(" "),a("p",[a("code",[t._v("__proto__")]),t._v("的指向，根据ECMA的定义'to the value of its constructor’s \"prototype\" ' ---指向创建这个对象的函数的显式原型。\n所以关键点还是在于找到创建这个对象的构造函数，在js中创建对象的方式")]),t._v(" "),a("ul",[a("li",[t._v("对象字面量的方式")]),t._v(" "),a("li",[a("code",[t._v("new")]),t._v("的方式")]),t._v(" "),a("li",[a("code",[t._v("Object.create()")])])]),t._v(" "),a("p",[t._v("对象字面量的方式其实本质上也是使用"),a("code",[t._v("new")]),t._v("，只是让开发人员更方便创建对象，而"),a("code",[t._v("Object.create()")]),t._v("方法，道格拉斯在2006年介绍了一种实现继承的方法，该方法并没使用严格意义上的构造函数，他的想法是借助原型可以基于已有的对象创建新对象，如下：")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("o")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("F")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("F")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" o\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("F")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("所以，其实从代码实现上，都是使用的"),a("code",[t._v("new")]),t._v("关键字的方式")]),t._v(" "),a("p",[t._v("在js只，万物皆对象，方法("),a("code",[t._v("Function")]),t._v(")是对象，方法的原型("),a("code",[t._v("Function.prototype")]),t._v(")是对象，因此，它们都会具有共同的特点。即：对象具有属性"),a("code",[t._v("__proto__")]),t._v("，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。")]),t._v(" "),a("p",[t._v("方法("),a("code",[t._v("Function")]),t._v(")这个特殊的对象，除了和其它对象一样有上述"),a("code",[t._v("__proto__")]),t._v("属性之外，还有自己特有的属性---原型属性("),a("code",[t._v("prototype")]),t._v(")，这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有类型的实例共享的属性和方法(我们把这个对象叫做原型对象)，在默认情况下，该对象会自动获取一个"),a("code",[t._v("constructor")]),t._v("(构造函数)属性，这个属性包含一个指向"),a("code",[t._v("prototype")]),t._v("属性所在函数的指针。")])])}),[],!1,null,null,null);s.default=n.exports}}]);